# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.4, generator: @autorest/python@6.4.7)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._operations._operations import (
    build_kameleo_local_api_add_cookies_request,
    build_kameleo_local_api_create_profile_request,
    build_kameleo_local_api_delete_cookies_request,
    build_kameleo_local_api_delete_profile_request,
    build_kameleo_local_api_duplicate_profile_request,
    build_kameleo_local_api_get_base_profile_search_parameters_request,
    build_kameleo_local_api_get_profile_status_request,
    build_kameleo_local_api_get_user_info_request,
    build_kameleo_local_api_healthcheck_request,
    build_kameleo_local_api_list_cookies_request,
    build_kameleo_local_api_list_profiles_request,
    build_kameleo_local_api_load_profile_request,
    build_kameleo_local_api_read_profile_request,
    build_kameleo_local_api_save_profile_request,
    build_kameleo_local_api_search_base_profiles_request,
    build_kameleo_local_api_start_profile_request,
    build_kameleo_local_api_start_profile_with_web_driver_settings_request,
    build_kameleo_local_api_stop_profile_request,
    build_kameleo_local_api_terminate_application_request,
    build_kameleo_local_api_test_proxy_request,
    build_kameleo_local_api_update_profile_request,
    build_kameleo_local_api_upgrade_profile_request,
)
from .._vendor import KameleoLocalApiClientMixinABC

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class KameleoLocalApiClientOperationsMixin(KameleoLocalApiClientMixinABC):  # pylint: disable=too-many-public-methods
    @distributed_trace_async
    async def get_base_profile_search_parameters(
        self,
        *,
        device_type: Optional[str] = None,
        os_family: Optional[str] = None,
        browser_product: Optional[str] = None,
        language: Optional[str] = None,
        **kwargs: Any
    ) -> _models.BaseProfileSearchParameters:
        """Get the possible values for base profile filtering. We can filter the available values. With
        this we can see for example that what languages of profiles do we have for Windows profiles
        with Chrome.

        Get the possible values for base profile filtering. We can filter the available values. With
        this we can see for example that what languages of profiles do we have for Windows profiles
        with Chrome.

        :keyword device_type: Filter option for the Device Type. Possible values are 'desktop',
         'mobile'. For example set it to mobile if you only want to see what os families we have for
         mobile profiles. Default value is None.
        :paramtype device_type: str
        :keyword os_family: Filter option for os family. Possible values are 'windows', 'macos',
         'linux', 'android', 'ios'. For example set it to windows if you only want to see what languages
         we have for windows profiles. Default value is None.
        :paramtype os_family: str
        :keyword browser_product: Filter option for browser product. Possible values are 'chrome',
         'firefox', 'edge', 'safari'. For example set it to safari if you only want to see what os
         families we have for chrome profiles. Default value is None.
        :paramtype browser_product: str
        :keyword language: Filter option for os language. Use ISO 639-1 language code format. For
         example set it to en-gb if you only want to see what browser products we have for English
         profiles. Default value is None.
        :paramtype language: str
        :return: BaseProfileSearchParameters
        :rtype: ~kameleo.local_api_client.models.BaseProfileSearchParameters
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BaseProfileSearchParameters] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_base_profile_search_parameters_request(
            device_type=device_type,
            os_family=os_family,
            browser_product=browser_product,
            language=language,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("BaseProfileSearchParameters", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def search_base_profiles(
        self,
        *,
        device_type: Optional[str] = None,
        os_family: Optional[str] = None,
        browser_product: Optional[str] = None,
        language: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.BaseProfilePreview]:
        """Filtering base profiles with some criteria. It will return X base profiles. It is not an
        idempotent method. This means if you are calling it twice after each other it may return a
        different set of base profiles.

        Filtering base profiles with some criteria. It will return X base profiles. It is not an
        idempotent method. This means if you are calling it twice after each other it may return a
        different set of base profiles.

        :keyword device_type: Filter option for the Device Type. Possible values are 'desktop',
         'mobile'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype device_type: str
        :keyword os_family: Filter option for os family. Possible values are 'windows', 'macos',
         'linux', 'android', 'ios'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype os_family: str
        :keyword browser_product: Filter option for browser product. Possible values are 'chrome',
         'firefox', 'edge', 'safari'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype browser_product: str
        :keyword language: Filter option for os language. Use ISO 639-1 language code format.
         For example, set it to en-gb if you want to get only English profiles from Great-Britain.
         You can also use a comma-separated list to provide more than one value.
         This field also supports wildcard for the sublanguage part: to retrieve both en-us, en-gb, and
         en-ca profiles, use 'en-*' as value. Default value is None.
        :paramtype language: str
        :return: list of BaseProfilePreview
        :rtype: list[~kameleo.local_api_client.models.BaseProfilePreview]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BaseProfilePreview]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_search_base_profiles_request(
            device_type=device_type,
            os_family=os_family,
            browser_product=browser_product,
            language=language,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BaseProfilePreview]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def list_cookies(self, guid: str, **kwargs: Any) -> List[_models.BrowserCookie]:
        """Gets the list of the cookies of the profile.

        Gets the list of the cookies of the profile.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BrowserCookie]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_list_cookies_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BrowserCookie]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def add_cookies(
        self,
        guid: str,
        body: Optional[List[_models.CookieRequest]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: list[~kameleo.local_api_client.models.CookieRequest]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_cookies(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_cookies(
        self, guid: str, body: Optional[Union[List[_models.CookieRequest], IO]] = None, **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a [CookieRequest] type or a IO type. Default value is None.
        :type body: list[~kameleo.local_api_client.models.CookieRequest] or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.BrowserCookie]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "[CookieRequest]")
            else:
                _json = None

        request = build_kameleo_local_api_add_cookies_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BrowserCookie]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def delete_cookies(self, guid: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes the cookies of the profile.

        Deletes the cookies of the profile.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_delete_cookies_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def healthcheck(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Health check request to test if Kameleo has been started and accepting connections.

        Health check request to test if Kameleo has been started and accepting connections.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_healthcheck_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_user_info(self, **kwargs: Any) -> _models.UserInfoResponse:
        """Provides information about the user.

        Provides information about the user.

        :return: UserInfoResponse
        :rtype: ~kameleo.local_api_client.models.UserInfoResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UserInfoResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_user_info_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("UserInfoResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def terminate_application(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Terminates the Kameleo session by deauthenticating and exiting the CLI. It is important to call
        it after operating with Kameleo, so other users of the team account won't be logged out.

        Terminates the Kameleo session by deauthenticating and exiting the CLI. It is important to call
        it after operating with Kameleo, so other users of the team account won't be logged out.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_terminate_application_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    async def test_proxy(
        self, body: Optional[_models.TestProxyRequest] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TestProxyResponse:
        """Tests a provided proxy connection.

        Tests a provided proxy connection.

        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.TestProxyRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TestProxyResponse
        :rtype: ~kameleo.local_api_client.models.TestProxyResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def test_proxy(
        self, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TestProxyResponse:
        """Tests a provided proxy connection.

        Tests a provided proxy connection.

        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TestProxyResponse
        :rtype: ~kameleo.local_api_client.models.TestProxyResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def test_proxy(
        self, body: Optional[Union[_models.TestProxyRequest, IO]] = None, **kwargs: Any
    ) -> _models.TestProxyResponse:
        """Tests a provided proxy connection.

        Tests a provided proxy connection.

        :param body: Is either a TestProxyRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.TestProxyRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: TestProxyResponse
        :rtype: ~kameleo.local_api_client.models.TestProxyResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.TestProxyResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "TestProxyRequest")
            else:
                _json = None

        request = build_kameleo_local_api_test_proxy_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.TestProxyResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("TestProxyResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def list_profiles(self, **kwargs: Any) -> List[_models.ProfilePreview]:
        """Gets a preview list about profiles that are currently in the system.

        Gets a preview list about profiles that are currently in the system.

        :return: list of ProfilePreview
        :rtype: list[~kameleo.local_api_client.models.ProfilePreview]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProfilePreview]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_list_profiles_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[ProfilePreview]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create_profile(
        self,
        body: Optional[_models.CreateProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected BaseProfile and inputs.

        Creates a new profile based on a selected BaseProfile and inputs.

        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.CreateProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_profile(
        self, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected BaseProfile and inputs.

        Creates a new profile based on a selected BaseProfile and inputs.

        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_profile(
        self, body: Optional[Union[_models.CreateProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected BaseProfile and inputs.

        Creates a new profile based on a selected BaseProfile and inputs.

        :param body: Is either a CreateProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.CreateProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_create_profile_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def update_profile(
        self,
        guid: str,
        body: Optional[_models.UpdateProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.UpdateProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_profile(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_profile(
        self, guid: str, body: Optional[Union[_models.UpdateProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a UpdateProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.UpdateProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_update_profile_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def read_profile(self, guid: str, **kwargs: Any) -> _models.ProfileResponse:
        """Returns a profile from the system.

        Returns a profile from the system.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_read_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def delete_profile(self, guid: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Removes profile from the system. When you are launching and stopping a big number of profiles
        for example for scraping it is recommended to call this after you have stopped the profile.
        This will free up disk space.

        Removes profile from the system. When you are launching and stopping a big number of profiles
        for example for scraping it is recommended to call this after you have stopped the profile.
        This will free up disk space.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_delete_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_profile_status(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Returns the current status of the profile.

        Returns the current status of the profile.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_profile_status_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def start_profile(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Starts a profile. The browser will be launched. In case of mobile profiles and external
        launcher types the external spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        Starts a profile. The browser will be launched. In case of mobile profiles and external
        launcher types the external spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_start_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def start_profile_with_web_driver_settings(
        self,
        guid: str,
        body: Optional[_models.WebDriverSettings] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.WebDriverSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def start_profile_with_web_driver_settings(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def start_profile_with_web_driver_settings(
        self, guid: str, body: Optional[Union[_models.WebDriverSettings, IO]] = None, **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a WebDriverSettings type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.WebDriverSettings or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "WebDriverSettings")
            else:
                _json = None

        request = build_kameleo_local_api_start_profile_with_web_driver_settings_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def stop_profile(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Stops a profile. The browsers will be stopped. In case of mobile profiles and external launcher
        types the external spoofing engine will be stopped.
        If successful, the profile's lifetime state will be 'terminated'. Otherwise the profile's
        lifetime state will be 'running'. During the api call the lifetime state can be 'terminating'
        for a temporarily.

        Stops a profile. The browsers will be stopped. In case of mobile profiles and external launcher
        types the external spoofing engine will be stopped.
        If successful, the profile's lifetime state will be 'terminated'. Otherwise the profile's
        lifetime state will be 'running'. During the api call the lifetime state can be 'terminating'
        for a temporarily.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_stop_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def save_profile(
        self,
        guid: str,
        body: Optional[_models.SaveProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.SaveProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def save_profile(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def save_profile(
        self, guid: str, body: Optional[Union[_models.SaveProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a SaveProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.SaveProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SaveProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_save_profile_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def duplicate_profile(self, guid: str, **kwargs: Any) -> _models.ProfileResponse:
        """Creates a duplicate of a loaded profile in memory. The created profile contains all the profile
        settings, browsing data, cookies, history, bookmarks and installed extensions. This operation
        does not perform any filesystem activity and will not affect your existing profile.

        Creates a duplicate of a loaded profile in memory. The created profile contains all the profile
        settings, browsing data, cookies, history, bookmarks and installed extensions. This operation
        does not perform any filesystem activity and will not affect your existing profile.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_duplicate_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def load_profile(
        self,
        body: Optional[_models.LoadProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.LoadProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def load_profile(
        self, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def load_profile(
        self, body: Optional[Union[_models.LoadProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        :param body: Is either a LoadProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.LoadProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "LoadProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_load_profile_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def upgrade_profile(self, guid: str, **kwargs: Any) -> Optional[_models.ProfileResponse]:
        """Upgrades the profile to the latest available browser version from the server. The exact target
        of the upgrade depends on the profile's current device, browser, operating system, and language
        settings.

        Upgrades the profile to the latest available browser version from the server. The exact target
        of the upgrade depends on the profile's current device, browser, operating system, and language
        settings.

        :param guid: Required.
        :type guid: str
        :return: ProfileResponse or None
        :rtype: ~kameleo.local_api_client.models.ProfileResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ProfileResponse]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_upgrade_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
