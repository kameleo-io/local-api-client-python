# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.6, generator: @autorest/python@6.5.1)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._operations._operations import (
    build_kameleo_local_api_add_cookies_request,
    build_kameleo_local_api_create_profile_request,
    build_kameleo_local_api_delete_cookies_request,
    build_kameleo_local_api_delete_profile_request,
    build_kameleo_local_api_duplicate_profile_request,
    build_kameleo_local_api_export_profile_request,
    build_kameleo_local_api_get_base_profile_search_parameters_request,
    build_kameleo_local_api_get_profile_status_request,
    build_kameleo_local_api_get_user_info_request,
    build_kameleo_local_api_healthcheck_request,
    build_kameleo_local_api_import_profile_request,
    build_kameleo_local_api_list_cookies_request,
    build_kameleo_local_api_list_profiles_request,
    build_kameleo_local_api_read_profile_request,
    build_kameleo_local_api_search_base_profiles_request,
    build_kameleo_local_api_start_profile_request,
    build_kameleo_local_api_start_profile_with_options_request,
    build_kameleo_local_api_stop_profile_request,
    build_kameleo_local_api_terminate_application_request,
    build_kameleo_local_api_update_profile_request,
    build_kameleo_local_api_upgrade_profile_request,
)
from .._vendor import KameleoLocalApiClientMixinABC

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class KameleoLocalApiClientOperationsMixin(KameleoLocalApiClientMixinABC):  # pylint: disable=too-many-public-methods
    @distributed_trace_async
    async def get_base_profile_search_parameters(
        self,
        *,
        device_type: Optional[str] = None,
        os_family: Optional[str] = None,
        browser_product: Optional[str] = None,
        language: Optional[str] = None,
        **kwargs: Any
    ) -> _models.BaseProfileSearchParameters:
        """Retrieves the available filtering options for base profiles, including device types, operating
        system families, browser products, and languages. This enables you to refine the selection, for
        example, to see which languages are available for profiles using Windows with Chrome.

        Retrieves the available filtering options for base profiles, including device types, operating
        system families, browser products, and languages. This enables you to refine the selection, for
        example, to see which languages are available for profiles using Windows with Chrome.

        :keyword device_type: Filter option for the Device Type. Possible values are 'desktop',
         'mobile'. For example set it to mobile if you only want to see what os families we have for
         mobile profiles. Default value is None.
        :paramtype device_type: str
        :keyword os_family: Filter option for os family. Possible values are 'windows', 'macos',
         'linux', 'android', 'ios'. For example set it to windows if you only want to see what languages
         we have for windows profiles. Default value is None.
        :paramtype os_family: str
        :keyword browser_product: Filter option for browser product. Possible values are 'chrome',
         'firefox', 'edge', 'safari'. For example set it to safari if you only want to see what os
         families we have for chrome profiles. Default value is None.
        :paramtype browser_product: str
        :keyword language: Filter option for os language. Use ISO 639-1 language code format. For
         example set it to en-gb if you only want to see what browser products we have for English
         profiles. Default value is None.
        :paramtype language: str
        :return: BaseProfileSearchParameters
        :rtype: ~kameleo.local_api_client.models.BaseProfileSearchParameters
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BaseProfileSearchParameters] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_base_profile_search_parameters_request(
            device_type=device_type,
            os_family=os_family,
            browser_product=browser_product,
            language=language,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("BaseProfileSearchParameters", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def search_base_profiles(
        self,
        *,
        device_type: Optional[str] = None,
        os_family: Optional[str] = None,
        browser_product: Optional[str] = None,
        language: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.BaseProfilePreview]:
        """Retrieves a set of 25 base profiles based on specified criteria, with the most recent browser
        versions at the beginning of the list. Note that calling this method multiple times will return
        different sets of base profiles.

        Retrieves a set of 25 base profiles based on specified criteria, with the most recent browser
        versions at the beginning of the list. Note that calling this method multiple times will return
        different sets of base profiles.

        :keyword device_type: Filter option for the Device Type. Possible values are 'desktop',
         'mobile'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype device_type: str
        :keyword os_family: Filter option for os family. Possible values are 'windows', 'macos',
         'linux', 'android', 'ios'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype os_family: str
        :keyword browser_product: Filter option for browser product. Possible values are 'chrome',
         'firefox', 'edge', 'safari'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype browser_product: str
        :keyword language: Filter option for os language. Use ISO 639-1 language code format.
         For example, set it to en-gb if you want to get only English profiles from Great-Britain.
         You can also use a comma-separated list to provide more than one value.
         This field also supports wildcard for the sublanguage part: to retrieve both en-us, en-gb, and
         en-ca profiles, use 'en-*' as value. Default value is None.
        :paramtype language: str
        :return: list of BaseProfilePreview
        :rtype: list[~kameleo.local_api_client.models.BaseProfilePreview]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BaseProfilePreview]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_search_base_profiles_request(
            device_type=device_type,
            os_family=os_family,
            browser_product=browser_product,
            language=language,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BaseProfilePreview]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def list_cookies(self, guid: str, **kwargs: Any) -> List[_models.BrowserCookie]:
        """Retrieves the list of cookies stored in the profile's browser. Note that this list does not
        include session cookies, which are not persisted between browser launches.

        Retrieves the list of cookies stored in the profile's browser. Note that this list does not
        include session cookies, which are not persisted between browser launches.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BrowserCookie]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_list_cookies_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BrowserCookie]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def add_cookies(
        self,
        guid: str,
        body: Optional[List[_models.CookieRequest]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: list[~kameleo.local_api_client.models.CookieRequest]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_cookies(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_cookies(
        self, guid: str, body: Optional[Union[List[_models.CookieRequest], IO]] = None, **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a [CookieRequest] type or a IO type. Default value is None.
        :type body: list[~kameleo.local_api_client.models.CookieRequest] or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.BrowserCookie]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "[CookieRequest]")
            else:
                _json = None

        request = build_kameleo_local_api_add_cookies_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BrowserCookie]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def delete_cookies(self, guid: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes all the cookies stored in the profile, which will likely log the profile out of all
        websites.

        Deletes all the cookies stored in the profile, which will likely log the profile out of all
        websites.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_delete_cookies_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def healthcheck(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Health check request to test if Kameleo has been started and accepting connections.

        Health check request to test if Kameleo has been started and accepting connections.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_healthcheck_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_user_info(self, **kwargs: Any) -> _models.UserInfoResponse:
        """Provides information about the user.

        Provides information about the user.

        :return: UserInfoResponse
        :rtype: ~kameleo.local_api_client.models.UserInfoResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UserInfoResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_user_info_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("UserInfoResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def terminate_application(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Terminates the Kameleo session by deauthenticating and exiting the CLI. It is important to call
        it after operating with Kameleo, so other users of the team account won't be logged out.

        Terminates the Kameleo session by deauthenticating and exiting the CLI. It is important to call
        it after operating with Kameleo, so other users of the team account won't be logged out.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_terminate_application_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def list_profiles(self, **kwargs: Any) -> List[_models.ProfilePreview]:
        """Gets a list of the profiles that are loaded in the current workspace.

        Gets a list of the profiles that are loaded in the current workspace.

        :return: list of ProfilePreview
        :rtype: list[~kameleo.local_api_client.models.ProfilePreview]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProfilePreview]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_list_profiles_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[ProfilePreview]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create_profile(
        self,
        body: Optional[_models.CreateProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected BaseProfile and inputs.

        Creates a new profile based on a selected BaseProfile and inputs.

        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.CreateProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_profile(
        self, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected BaseProfile and inputs.

        Creates a new profile based on a selected BaseProfile and inputs.

        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_profile(
        self, body: Optional[Union[_models.CreateProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected BaseProfile and inputs.

        Creates a new profile based on a selected BaseProfile and inputs.

        :param body: Is either a CreateProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.CreateProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_create_profile_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def update_profile(
        self,
        guid: str,
        body: Optional[_models.UpdateProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.UpdateProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_profile(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_profile(
        self, guid: str, body: Optional[Union[_models.UpdateProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a UpdateProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.UpdateProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_update_profile_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def read_profile(self, guid: str, **kwargs: Any) -> _models.ProfileResponse:
        """Gets the profile with the specified ID from the current workspace. On startup, Kameleo will
        automatically scan and load profiles stored in your workspace folder.

        Gets the profile with the specified ID from the current workspace. On startup, Kameleo will
        automatically scan and load profiles stored in your workspace folder.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_read_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def delete_profile(self, guid: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Irreversibly deletes a profile from the current workspace, freeing up disk space and removing
        all associated data. It is recommended to create a backup using the export function before
        deleting a profile, as this operation is permanent and can result in data loss.

        Irreversibly deletes a profile from the current workspace, freeing up disk space and removing
        all associated data. It is recommended to create a backup using the export function before
        deleting a profile, as this operation is permanent and can result in data loss.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_delete_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_profile_status(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Returns the current status information about a profile, including its save state, lifetime
        state, and the connection port for profiles using an external spoofing engine.

        Returns the current status information about a profile, including its save state, lifetime
        state, and the connection port for profiles using an external spoofing engine.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_profile_status_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def start_profile(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Starts the selected profile by transitioning its status to 'starting', launching the browser
        engine associated with the profile, and then changing its status to 'running'. If there is an
        error during start up, it will be 'terminated'. You can use the launcher property to override
        the browser engine before the first start.

        Starts the selected profile by transitioning its status to 'starting', launching the browser
        engine associated with the profile, and then changing its status to 'running'. If there is an
        error during start up, it will be 'terminated'. You can use the launcher property to override
        the browser engine before the first start.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_start_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def start_profile_with_options(
        self,
        guid: str,
        body: Optional[_models.WebDriverSettings] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.WebDriverSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def start_profile_with_options(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def start_profile_with_options(
        self, guid: str, body: Optional[Union[_models.WebDriverSettings, IO]] = None, **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a WebDriverSettings type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.WebDriverSettings or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "WebDriverSettings")
            else:
                _json = None

        request = build_kameleo_local_api_start_profile_with_options_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def stop_profile(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Stops the selected profile and optionally releases resources. The browser engine (desktop
        browsers or external spoofing engine) associated with the profile is closed, and the profile's
        status is changed to 'terminated'.

        Stops the selected profile and optionally releases resources. The browser engine (desktop
        browsers or external spoofing engine) associated with the profile is closed, and the profile's
        status is changed to 'terminated'.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_stop_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def export_profile(
        self,
        guid: str,
        body: Optional[_models.ExportProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.ExportProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def export_profile(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def export_profile(
        self, guid: str, body: Optional[Union[_models.ExportProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a ExportProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.ExportProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ExportProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_export_profile_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def duplicate_profile(self, guid: str, **kwargs: Any) -> _models.ProfileResponse:
        """Creates a copy of the loaded profile, which is saved to the workspace on the filesystem. The
        duplicated profile will have a new ID, but will retain all the settings, browsing data,
        cookies, history, bookmarks, and installed extensions of the original profile.

        Creates a copy of the loaded profile, which is saved to the workspace on the filesystem. The
        duplicated profile will have a new ID, but will retain all the settings, browsing data,
        cookies, history, bookmarks, and installed extensions of the original profile.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_duplicate_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def import_profile(
        self,
        body: Optional[_models.ImportProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.ImportProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def import_profile(
        self, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def import_profile(
        self, body: Optional[Union[_models.ImportProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        :param body: Is either a ImportProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.ImportProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ImportProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_import_profile_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def upgrade_profile(self, guid: str, **kwargs: Any) -> Optional[_models.ProfileResponse]:
        """Upgrades the profile to the most recent browser version available from the server, tailored to
        the profile's current device, browser, operating system, and language settings. Note that
        upgrading a profile will alter its browser fingerprint.

        Upgrades the profile to the most recent browser version available from the server, tailored to
        the profile's current device, browser, operating system, and language settings. Note that
        upgrading a profile will alter its browser fingerprint.

        :param guid: Required.
        :type guid: str
        :return: ProfileResponse or None
        :rtype: ~kameleo.local_api_client.models.ProfileResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ProfileResponse]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_upgrade_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
